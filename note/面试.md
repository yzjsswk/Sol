#### 自我介绍
面试官好, 我叫叶志杰, 是一名来自扬州大学的大四应届毕业生, 我的专业是计算机科学与技术. 
在学校我学习了数据结构, 操作系统等等一些计算机相关课程, 取得了不错的成绩.
然后除了学习专业知识, 大学期间我主要参加了很多竞赛, 以程序设计类为主, 例如ACM, 蓝桥杯等等.
我是大二的时候加入了我们学校的ACM集训队，之后就花费了很多时间在算法和程序设计上.
在这期间我感觉我的coding能力和算法设计能力大大提高了.
后来因为在我们学校获奖比较突出, 大三的时候就成为了集训队的学生教练.
主要负责带新人学习一些算法, 还有举办一些训练赛, 
然后我们学校的一些ACM或者蓝桥杯比赛会有一个校选拔赛, 这个校选拔赛也是我负责出题的.
然后我们集训队在后来的比赛中也取得的不错的成绩. 

#### 项目介绍

#### 设计模式

#### 数据结构和算法
哈希表的设计和遍历
排序算法 稳定性
LC.72 编辑距离 
4.一个横轴，上面有若干个小球，每个小球有一个初始位置和速度，速度值可以为负（负代表反方向）。运动开始之后，若两小球碰撞之后，会两两消失，问如何求得什么时候小球消失，以及使哪两个小球消失。 
两个线程分别打印奇数偶数, 要求有锁的竞争
LC.1143 最长公共子序列
最长无重复子串

#### C/C++
C++11, 移动语义, vector的实现, 扩容, 操作效率, map和unodered_map

多态, 虚函数, 虚函数表中的内容, 子类调用父类虚函数的过程
Class A和Class B, B继承A时的函数调用, Class的sizeof
staic inline 多态 虚函数
四种强制类型转换(cast?), 内存泄露的几种情况
智能指针, 空类里的函数
重载, 重写, 覆盖区别
new malloc区别
内存对齐
extern 和 extern C
虚继承, 虚基类表指针, 析构函数构造函数能否为虚函数
ifndef def endif作用
循环展开

#### 操作系统
epoll及实现原理
epoll多路复用
mutex和semaphore
进程间通信, 共享内存
内核态, 用户态
多线程怎么通信
介绍进程和线程, 进程为什么比线程操作复杂
进程和线程的区别, 浏览器有哪些进程和线程
线程的共享部分, 私有部分
为什么进程切换消耗大, 切换了哪些资源(堆栈)
虚拟内存
内存碎片
协程
死锁, 如何避免, 有了如何解决
linux开机过程
synchronized锁的底层原理, 膨胀机制

#### 网络
TCP三次握手, 四次挥手, 为什么要三次握手, 不是三次会有什么问题, 三次握手还有什么问题
TCP如何最大程度利用带宽
TCP一个报文设置多大合适
time_wait close_wait
socket编程
TCP和UDP的区别
tcp流量控制和拥塞控制算法, 快速恢复怎么实现, QUIC协议
HTTP和HTTPS的区别, HTTPS的握手过程
OSI分层, 协议
网址从输入到显示出来有哪些过程
HTTP1.1和2, 3的区别
DNS工作原理
DHCP, DDOS攻击, TCP连接和断连

#### 数据库
候选键: 能决定其他属性的属性集合(可能不唯一)
主键: 候选键中的任何一个集合
主属性: 主键中的任何一个属性

六大范式
: [1, 2, 3, BC, 4, 5]NF
    1NF: 字段不可分, 关系型数据库的必要条件
    2NF: 要有主键(但主键可能不唯一, 非主属性可能传递或部分依赖主属性)
    3NF: 非主属性要直接依赖主键, 不能传递或部分

五大约束
: 主键, 外键, 非空, unique, 默认值

数据库的完整性
: 实体完整性: 主键要unique且not null
    参照完整性: 外键的正确性, 非法修改时默认拒绝, 
    对于被参照表还可以选择级联操作或者设置为空,要在创建参照时显示说明
    用户自定义的完整性: 按照实际意义赋予的约束

Mysql事务四大特性ACID
: A 原子性: 事务是一个不可分割的整体, 要么一起执行成功, 要么一起失败(commit rollback)
    C 一致性: 执行前后不能改变数据库的完整性(四大特性的最终目的)
    I 隔离性: 有隔离机制保证并发事务执行独立运行
    D 持久性: 事务一旦提交或回滚, 改变就是永久的(数据库发生故障也不会丢失)

ACID怎么保证
: A 原子性: commit, rollback, 撤销日志 undo log
    D 持久性: 提交事务前先写入 redo log, 发生故障后通过redo log恢复
    I 隔离性: 隔离机制, MVCC(读写)(快照读, 当前读), 锁(写写)
    C 一致性: ADI最终目的, Crash Recovery, Doublewrite Buffer

并发事务问题
: 1. 脏读: B读了A修改但未提交的数据, A回滚会导致B读的数据失去意义
    2. 不可重复读: B多次读同一条数据, 在这之间穿插A的多次修改(带提交), B每次读到的数据不一样
    3. 幻读: 类似不可重复读, 但是侧重于某条或某些数据的存在与否, 刚刚不存在, 现在又存在了, 像产生幻觉

事务隔离级别
: 1. 读未提交(三种问题都会出现)
    2. 读已提交(不会出现脏读)
    3. 可重复读(不会出现脏读, 不可重复读) 
        #Mysql在此隔离级别下通过当前读和快照读在一定程度上解决了幻读问题, lock in share mode
    4. 串行化(都不会出现)

可重复读怎么实现: MVCC(在表的后面加了两列记录创建时间和版本号)
当前读怎么实现: next-key锁(行锁+Gap锁)
快照读怎么实现: undo log 和 MVCC
幻读怎么解决: 可重复度下快照读+当前度, 串行化下通过锁机制(读加表级共享锁, 写加表级排他锁)

mysql中的锁
: 粒度: 全局锁(锁库), 表级锁(锁表), 行级锁(锁行)
    加锁机制: 乐观锁, 悲观锁
    兼容性: 共享锁(S锁, 只允许读), 排他锁(X锁, 允许读写)
    锁模式: 记录锁, gap锁, next-key锁, 意向锁, 间隙锁
    
mysql索引
: 聚集索引和非聚集索引: 聚集索引实际上在保存表中的数据的时候顺便做了一个索引, 
    它的叶子结点保存的就是表中的row, 这些row的存储在物理上是连续的, 
    然后聚集索引一张表只能有一个, 一般默认是主键
    非聚集索引的叶子节点存储的是聚集索引的索引列的值, 
    找到之后然后要再去聚集索引中找到实际的数据, 也叫二级索引, 可以有多个
    普通索引, 唯一索引(unique可以null), 主键索引(unique, not null), 全文索引
    单列索引, 联合索引(多列)
    索引失效的情况: 1. 违背最左匹配原则2. 对索引字段做函数运算3.数字串不加引号4.like前面%
    5.or 6.!= 7.其他mysql优化器认为全表扫描更优的情况


数据库的死锁
: 1.死锁四个条件: 互斥, 请求与保持, 不剥夺, 循环等待
    1. 死锁的预防: 避免进程永久占用资源, 防止进程在等待状态占用资源, 合理规划资源分配(银行家算法)
        具体的, a. 不同的事务按同一顺序访问对象 b. 尽量减小事务规模以即时释放锁
        c. 使用低隔离级别, 低隔离级别对访问安全性的约束会更少, 死锁也会更少
    2. 已经发生了死锁怎么解决: show status查看日志, 分析索引情况, 优化sql

数据库软件?


