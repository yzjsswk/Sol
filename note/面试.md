#### 自我介绍
面试官好, 我叫叶志杰, 来自扬州大学, 今年是大四应届毕业
我的专业是计算机科学与技术
在学校期间除了学习专业知识, 我主要参加了许多竞赛, 以程序设计类为主, 例如ACM和蓝桥杯等等
我是大二的时候加入了我们学校的ACM集训队，然后就花费了很多时间在算法和程序设计上
在这期间我感觉我的coding能力和算法设计能力大大提高了
后来因为在我们学校获奖比较突出, 大三的时候就成为了集训队的学生教练
主要负责带新人学习一些算法, 还有举办一些训练赛 
然后因为我们打比赛主要是用这个C++嘛, 所以我对C++会比较熟悉

#### C/C++

##### C++11常用新特性
nullptr, auto decltype, for_each循环, 列表初始化, lamba表达式, 哈希容器, >>  

##### 多态
静态多态(编译时确定): 重载, 模板
动态多态(运行时确定): 虚函数

重载 overload
普通函数重载/成员函数重载(运算符重载)
要在同一个范围内, 函数名要相同, 参数列表要不同, 不关心返回值

重写 override
虚函数, 基类要有virtual关键字, 函数名, 参数列表, 返回值都要相同, 否则是覆盖
返回值相同: 基本类型必须相同, 如果基类中返回值是自定义类型, 派生类中返回值可以是该类型的派生

覆盖(隐藏)
派生类中的函数隐藏了基类的函数

重写和覆盖: 不是虚函数按指针类型调用, 虚函数按指向的对象类型调用




    多态, 虚函数, 虚函数表中的内容, 子类调用父类虚函数的过程
    虚继承, 虚基类表指针, 析构函数构造函数能否为虚函数

空类里的函数: 默认的构造, 拷贝构造, 析构, 赋值运算取址运算 取值运算const

new malloc区别

static const
extern 和 extern C
四种强制类型转换(cast?), 内存泄露的几种情况
智能指针



#### 操作系统
epoll及实现原理
epoll多路复用
mutex和semaphore
进程间通信, 共享内存
内核态, 用户态
多线程怎么通信
介绍进程和线程, 进程为什么比线程操作复杂
进程和线程的区别, 浏览器有哪些进程和线程
线程的共享部分, 私有部分
为什么进程切换消耗大, 切换了哪些资源(堆栈)
虚拟内存
内存碎片
协程
死锁, 如何避免, 有了如何解决
linux开机过程
synchronized锁的底层原理, 膨胀机制

#### 网络

##### TCP/IP分层
应用层: HTTP, DNS, DHCP, FTP, SMTP
传输层: TCP, UDP 端到端
网络层: IP 点到点 路由
数据链路层: ARP(IP->MAC) 设备到设备(一条链路)
物理层: 010101...

##### OSI分层
应用层, 表示层, 会话层, 传输层, 网络层, 数据链路层, 物理层

##### HTTP状态码
1xx: 提示信息, 正在处理, 不太常见
2xx: 成功, 发送的请求被正确处理(200, 204, 206)
3xx: 重定向, 请求的资源位置发生变化, 要重新请求(301, 302, 304)
4xx: 客户端错误, 请求的报文有误, 服务器无法处理(400default, 403禁止访问, 404找不到资源)
5xx: 服务器错误, 服务器处理请求时发生了错误(500defaut, 501暂未开放, 502后端错误, 503服务器忙)

##### http字段
host: 指定要访问的服务器的域名(www.xxx)
Connection: 1.1默认是持久连接 Keep alive
Content-length, Content-type: 服务器返回数据的类型和长度
(客户端可以使用accept字段说明自己可以接受的数据格式)
Content-Encoding: 服务器返回数据的压缩格式

##### TCP和UDP的区别
TCP要建立连接, UDP不需要建立连接
TCP是一对一的, UDP可以一对多或者多对多
TCP是可靠的, TCP有校验和, 有序列号, 有确认应答机制来确保数据传输不会出错
此外TCP还有流量控制, 拥塞控制和超时重传机制, 
而这些UDP都是没有的, UDP是很纯粹的发送数据, 所以我们说UDP是不可靠的
但是同时这也使得TCP的效率低于UDP, 因为它要做很多工作嘛, 而UDP不用
TCP头部(20+)比UDP(8)大
TCP在传输层分片, UDP在IP层分片
应用场景: TCP : HTTP, HTTPS, FTP; UDP: DNS, DHCP, 视频音频广播



TCP三次握手, 四次挥手, 为什么要三次握手, 不是三次会有什么问题, 三次握手还有什么问题
time_wait close_wait


tcp流量控制和拥塞控制算法, 快速恢复怎么实现, QUIC协议
HTTP和HTTPS的区别, HTTPS的握手过程

网址从输入到显示出来有哪些过程
HTTP1.1和2, 3的区别
DNS工作原理
DHCP, TCP连接和断连


TCP如何最大程度利用带宽
TCP一个报文设置多大合适

#### 数据库
候选键: 能决定其他属性的属性集合(可能不唯一)
主键: 候选键中的任何一个集合
主属性: 主键中的任何一个属性

六大范式
: [1, 2, 3, BC, 4, 5]NF
    1NF: 字段不可分, 关系型数据库的必要条件
    2NF: 要有主键(但主键可能不唯一, 非主属性可能传递或部分依赖主属性)
    3NF: 非主属性要直接依赖主键, 不能传递或部分

五大约束
: 主键, 外键, 非空, unique, 默认值

数据库的完整性
: 实体完整性: 主键要unique且not null
    参照完整性: 外键的正确性, 非法修改时默认拒绝, 
    对于被参照表还可以选择级联操作或者设置为空,要在创建参照时显示说明
    用户自定义的完整性: 按照实际意义赋予的约束

Mysql事务四大特性ACID
: A 原子性: 事务是一个不可分割的整体, 要么一起执行成功, 要么一起失败(commit rollback)
    C 一致性: 执行前后不能改变数据库的完整性(四大特性的最终目的)
    I 隔离性: 有隔离机制保证并发事务执行独立运行
    D 持久性: 事务一旦提交或回滚, 改变就是永久的(数据库发生故障也不会丢失)

ACID怎么保证
: A 原子性: commit, rollback, 撤销日志 undo log
    D 持久性: 提交事务前先写入 redo log, 发生故障后通过redo log恢复
    I 隔离性: 隔离机制, MVCC(读写)(快照读, 当前读), 锁(写写)
    C 一致性: ADI最终目的, Crash Recovery, Doublewrite Buffer

并发事务问题
: 1. 脏读: B读了A修改但未提交的数据, A回滚会导致B读的数据失去意义
    2. 不可重复读: B多次读同一条数据, 在这之间穿插A的多次修改(带提交), B每次读到的数据不一样
    3. 幻读: 类似不可重复读, 但是侧重于某条或某些数据的存在与否, 刚刚不存在, 现在又存在了, 像产生幻觉

事务隔离级别
: 1. 读未提交(三种问题都会出现)
    2. 读已提交(不会出现脏读)
    3. 可重复读(不会出现脏读, 不可重复读) 
        #Mysql在此隔离级别下通过当前读和快照读在一定程度上解决了幻读问题, lock in share mode
    4. 串行化(都不会出现)

可重复读怎么实现: MVCC(在表的后面加了两列记录创建时间和版本号)
当前读怎么实现: next-key锁(行锁+Gap锁)
快照读怎么实现: undo log 和 MVCC
幻读怎么解决: 可重复度下快照读+当前度, 串行化下通过锁机制(读加表级共享锁, 写加表级排他锁)

mysql中的锁
: 粒度: 全局锁(锁库), 表级锁(锁表), 行级锁(锁行)
    加锁机制: 乐观锁, 悲观锁
    兼容性: 共享锁(S锁, 只允许读), 排他锁(X锁, 允许读写)
    锁模式: 记录锁, gap锁, next-key锁, 意向锁, 间隙锁
    
mysql索引
: 聚集索引和非聚集索引: 聚集索引实际上在保存表中的数据的时候顺便做了一个索引, 
    它的叶子结点保存的就是表中的row, 这些row的存储在物理上是连续的, 
    然后聚集索引一张表只能有一个, 一般默认是主键
    非聚集索引的叶子节点存储的是聚集索引的索引列的值, 
    找到之后然后要再去聚集索引中找到实际的数据, 也叫二级索引, 可以有多个
    普通索引, 唯一索引(unique可以null), 主键索引(unique, not null), 全文索引
    单列索引, 联合索引(多列)
    索引失效的情况: 1. 违背最左匹配原则2. 对索引字段做函数运算3.数字串不加引号4.like前面%
    5.or 6.!= 7.其他mysql优化器认为全表扫描更优的情况


数据库的死锁
: 1.死锁四个条件: 互斥, 请求与保持, 不剥夺, 循环等待
    1. 死锁的预防: 避免进程永久占用资源, 防止进程在等待状态占用资源, 合理规划资源分配(银行家算法)
        具体的, a. 不同的事务按同一顺序访问对象 b. 尽量减小事务规模以即时释放锁
        c. 使用低隔离级别, 低隔离级别对访问安全性的约束会更少, 死锁也会更少
    2. 已经发生了死锁怎么解决: show status查看日志, 分析索引情况, 优化sql


#### 其他
不稳定的排序算法: 堆排和快排, 选择排序, 希尔排序
