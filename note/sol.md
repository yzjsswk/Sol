

##### 

#### 寻找数组中满足特定条件的元素组合

##### LC.1 两数之和

给一个整数数组, 找和为$k$的两个数, 返回下标, 答案唯一

思路
: 从左往右遍历, 哈希记录每个数的值和下标, 遇到$x$找是(前面)否存在$k-x$, 时间复杂度$O(n)$

##### LC.15 三数之和

给一个整数数组, 找和为$0$的三个数, 答案不唯一, 找到所有不重复的三元组(顺序改变算同一种)

思路
:  先排序，固定其中一个数$k$，剩下的从一个最小i的和最大的j开始考虑，由于有序性，
每当和偏小时一定是小的那个变大($i$++)，每当和偏大时一定是大的那个变小($j$--)
因为答案不能重复，每当$k$，$i$，$j$移动时一定要跳过重复的一段到下一个不同的数字  
时间复杂度$O(n^2)$

##### LC.16 最接近的三数之和

给一个整数数组, 找和最近接$k$的三个数, 返回这个最接近的值

思路
: 同上一题, 每次考虑一个三元组时更新一下答案

##### LC.18 四数之和

给一个整数数组, 找和为$k$的四个数, 答案不唯一, 返回所有不重复的四元组

思路
: 同上两题, 只是每次固定两个数(前两维直接暴力枚举)
注意四个指针增加时都要跳过数字相同的一段
时间复杂度$O(n^3)$

#### Partition

$partition$是一种对数组进行原地筛选的算法, 它的目标是将满足筛选条件的元素都放到左边, 
不满足条件的元素都放到右边. 一种实现方式是从左往右遍历, 把合法的元素扔到左边, 
具体的, 用两个指针$i$, $j$, 其中$j$是遍历指针, $i$有两层含义: 
1. $i$的左边是已经筛选好的合法元素, 即$i$指向合法部分的下一个位置(若下标从$0$开始, $i$就是合法元素个数)  
2. 当$j$遇到一个不合法的元素时, 应该与$i$处元素交换, 即$i$指向的位置是下一个可以被交换的位置

时间复杂度$O(n)$, 空间复杂度$O(1)$

##### LC.27 移除元素

给一个数组, 删除值等于$k$的元素, 要求原地进行(即将合法部分放到数组前面并返回合法长度)

思路
: 最简单的$partition$模型, 这里的筛选条件是$x$不等于$k$

##### LC.905 按奇偶排序数组

给一个非负数组, 对它排序使得偶数都在前面, 奇数都在后面(奇偶内部次序不影响)

思路
: 筛选条件是$x$为偶数

##### LC.26 删除有序数组中的重复项

给一个有序数组, 删除其中的重复项(原地进行)

思路
: 用一个整数$cur$表示当前正在判断的那个数, 则这里的筛选条件就是$x$不等于$cur$
当下一个元素与$cur$不同时, 更新$cur$

##### LC.80 删除有序数组的重复项II

给一个有序数组, 每种元素最多允许出现两次, 删除多余的那些(原地进行)

思路
: 类似上题, 加一个$cnt$判断当前这个数已经出现的次数, 筛选条件为这个数未出现过或出现次数小于$2$

##### 洛谷P1177 快速排序

经典的快速排序算法

思路
: 将筛选条件设为$x<pivot$, 其中$pivot$是数组中的某个数, $partition$完后, 小于$pivot$的数
都在左边, 此时$i$指针的位置就是$pivot$在排序数组中应该所处的位置, 因此我们把$pivot$与
$i$指针处元素交换, 则$pivot$这个元素排序完成, 接下来递归处理左右两边即可.
平均情况下, 即每次划分都几乎把元素分为相等的两部分, 此时递归的层数为$log(n)$, 可知
时间复杂度为$O(nlog(n))$. 但是, 有两种情况会导致算法效率变低: 
   1. $pivot$选取不当, 例如选择数组中最大或最小的元素, 每次递归只能减少一个元素, 递归
   层数变为$n$, 总的复杂度变为$O(n^2)$, 解决方案是可以选择中位数或随机选择$pivot$
   2. 数组中有大量重复元素, 或更极端一点, 数组中元素全部相同, 此时$pivot$选取策略失效. 
    解决方案是调整$partition$的筛选策略, 对于值等于$pivot$的元素, 我们可以交替筛选, 
    一次要, 一次不要, 相当于筛选条件在$x < pivot$和$x \leq pivot$中来回切换, 这样可以
    把值等于$pivot$的元素平均的分配到两边, 使递归规模接近$n/2$.
        ```
        int partition(int arr[], int l, int r, int pivot){
            int i, j;
            i = j = l;
            int flag = 0;
            while(j < r){
                if(arr[j] < pivot){
                    swap(arr[i], arr[j]);
                    i++;
                }
                if(arr[j] == pivot){
                    if(flag){
                        swap(arr[i], arr[j]);
                        i++;
                        flag = 0;
                    }else{
                        flag = 1;
                    }
                }
                j++;
            }
            return i;
        }
        ```
##### 洛谷P1923 求第k小的数

给一个数组, 找到其中第$k$小的数, 最小的数是第$0$小

思路
: 仿照上题, 将筛选条件设为$x<pivot$, $partition$完后, 小于$pivot$的数都在左边, 假设有$k_1$个, 
可知$pivot$是数组中第$k_1$小的数, 如果$k_1$==$k$, 则$pivot$就是我们要找的答案, 如果$k_1$<$k$, 
说明第$k$小在右边, 往右递归; 如果$k_1$>$k$, 说明第$k$小的数在左边, 往左递归.  
平均情况下, $partition$的总长度为$n+n/2+n/4+ ... < 2n$, 因此时间复杂度为$O(n)$.
较坏情况的处理策略同上题.

#### 线段覆盖

##### 洛谷P1803 线段覆盖

数轴上有$n$条线段$(l_i, r_i)$, 问最多能选取多少条互不重叠的线段?

思路
: 贪心, 优先选$r$小的
先按$r$排序, 记录当前已选择的线段中最右边的$r$到哪里, 从$r$小的开始能选则选

##### BM96 主持人调度

数轴上有$n$条线段$(l_i, r_i)$, 问最多有多少条线段两两重叠?

思路
: 用一个优先队列, 存当前在某个位置都重叠的一些线段, 每次考虑一条新的线段时, 
如果它的$l$小于优先队列中最小的$r$, 则一定可以和优先队列中的所有线段都重叠, 
直接入队, 否则, 不断弹出优先队列中最小的$r$直到满足上述条件, 再入队并更新答
案(此时的答案就是优先队列的$size$), 注意这里不能使用单调栈, 因为比较是$r$与$l$之
间的比较, 入栈是入的是$r$, 并不能保证栈单调.

#### 其它

##### LC.31 下一个排列

求一个排列的下一个排列($next\_ permutation$)

思路
: 一种可以处理重复元素的步骤:
   1. 从后向前找第一个位置$i$, 满足$p[i]<p[i+1]$, 如果找不到, 说明字典序已经最大, 
    应该直接全部反转得到最小的字典序(但不需要特判, 对这种情况的处理逻辑是统一的)
    2. 从后向前找第一个位置$j$, 满足$p[i]<p[j]$, 交换$p[i],p[j]$
    3. 反转$[i+1,end]$中的元素(其实是将这些元素变成正序, 但可以证明此时它们一定是逆序)

```
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 2, j = n - 1;
        while(i >= 0 && nums[i] >= nums[i + 1]) i--;
        if(i >= 0) {
            while(j > i && nums[i] >= nums[j]) j--;
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```